

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Tutorial &mdash; PyMaxflow v0.0.3beta documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.0.3beta',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="PyMaxflow v0.0.3beta documentation" href="index.html" />
    <link rel="next" title="Maxflow package" href="maxflow.html" />
    <link rel="prev" title="Welcome to PyMaxflow’s documentation!" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="maxflow.html" title="Maxflow package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Welcome to PyMaxflow’s documentation!"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">PyMaxflow v0.0.3beta documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tutorial">
<span id="id1"></span><h1>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h1>
<p>This tutorial is
aimed to those who know the maximum flow problem
and its applications to computer vision and graphics.
It explains how to use the <em>PyMaxflow</em> library
in some key problems, but it assumes that the reader
knows the theoretic grounds behind them.</p>
<p>If the concepts <em>maxflow</em>, <em>mincut</em> or <em>Markov Random Field</em>
are not familiar to you, this tutorial might
be a waste of time. In that case, you may want to read
the <a class="reference external" href="http://en.wikipedia.org/wiki/Maximum_flow_problem">Wikipedia page</a>
on this topic and the tutorial <a class="reference internal" href="#boykov06">[BOYKOV06]</a>.</p>
<div class="section" id="getting-started">
<h2>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h2>
<p>Once you have installed the PyMaxflow library, you can
import it as usual:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">maxflow</span>
<span class="k">print</span> <span class="n">maxflow</span><span class="o">.</span><span class="n">__version__</span>
</pre></div>
</div>
</div>
<div class="section" id="a-first-example">
<h2>A first example<a class="headerlink" href="#a-first-example" title="Permalink to this headline">¶</a></h2>
<p>The first example consists on constructing and finding the maximum
flow of a custom graph:</p>
<a class="reference internal image-reference" href="_images/graph.png"><img alt="_images/graph.png" src="_images/graph.png" style="width: 233.5px; height: 363.0px;" /></a>
<p>This graph has two <em>terminal</em> nodes, the source <img class="math" src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/> and the sink <img class="math" src="_images/math/e0d2bf360290fd61d1c1557e763f2622363b3d35.png" alt="t"/>,
and two <em>non-terminal</em> nodes, labelled 0 and 1. The code for building
this graph is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">maxflow</span>

<span class="c"># Create a graph with integer capacities.</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">maxflow</span><span class="o">.</span><span class="n">Graph</span><span class="p">[</span><span class="nb">int</span><span class="p">](</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c"># Add two (non-terminal) nodes. Get the index to the first one.</span>
<span class="n">n0</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">add_nodes</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="c"># Create two edges (forwards and backwards) with the given capacities.</span>
<span class="c"># The indices of the nodes are always consecutive.</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span> <span class="n">n0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c"># Set the capacities of the terminal edges...</span>
<span class="c"># ...for the first node.</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_tedge</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="c"># ...for the second node.</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_tedge</span><span class="p">(</span><span class="n">n0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>Pretty straightforward, but some details worth mentioning.
First, the data type of the capacities can be <em>integer</em>,
as in the example, or <em>float</em>. In that case, the
graph construction should be:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">g</span> <span class="o">=</span> <span class="n">maxflow</span><span class="o">.</span><span class="n">Graph</span><span class="p">[</span><span class="nb">float</span><span class="p">](</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Second, the constructor parameters are an initial
estimation of the number of nodes and the number
of non-terminal edges. These estimations do not need
to be perfect, not even approximate. But a better
estimation will lead to a better performance in terms
of memory consumption. Please, consult the
documentation of the constructor for more details.
In this example, we exactly know how many nodes
and non-terminal edges the graph has when
we call the constructor.</p>
<p>Third, you do <em>not</em> have to create the terminal nodes.
Every graph have
implicitly defined both nodes. Moreover, you cannot create more
terminal nodes. The non-terminal edges (those connecting
two non-terminal nodes) are created with <tt class="docutils literal"><span class="pre">add_edge</span></tt>. The
terminal edges (those connecting a non-terminal node to a
terminal node) are created with <tt class="docutils literal"><span class="pre">add_tweights</span></tt>.</p>
<p>Now we can find the maximum flow in the graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">flow</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">maxflow</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&quot;Maximum flow:&quot;</span><span class="p">,</span> <span class="n">flow</span>
</pre></div>
</div>
<p>Finally, we want to know the shape of the partition
given by the minimum cut:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="s">&quot;Segment of the node 0:&quot;</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">get_segment</span><span class="p">(</span><span class="n">n0</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Segment of the node 1:&quot;</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">get_segment</span><span class="p">(</span><span class="n">n0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The method <tt class="docutils literal"><span class="pre">get_segment</span></tt> returns <tt class="docutils literal"><span class="pre">maxflow.SOURCE</span></tt> when the
given node belongs to the partition of the source node (i.e., the
minimum cut severs the terminal edge from the node to the sink),
or <tt class="docutils literal"><span class="pre">maxflow.SINK</span></tt> otherwise (i.e., the minimum cut severs
the terminal edge from the source to the node).</p>
<p>This example is available in <tt class="file docutils literal"><span class="pre">examples/simple.py</span></tt>. If you
run this code, you it will print:</p>
<div class="highlight-python"><pre>Maximum flow: 8
Segment of the node 0: SINK
Segment of the node 1: SOURCE</pre>
</div>
<p>This means that the minimum cut severs the graph in this way:</p>
<a class="reference internal image-reference" href="_images/graph2.png"><img alt="_images/graph2.png" src="_images/graph2.png" style="width: 233.5px; height: 363.0px;" /></a>
<p>The severed edges are marked with dashed lines. Indeed, the sum
of the capacities of these edges is equal to the maximum flow 8.</p>
</div>
<div class="section" id="binary-image-restoration">
<h2>Binary image restoration<a class="headerlink" href="#binary-image-restoration" title="Permalink to this headline">¶</a></h2>
<p>Now we proceed to a more involved example.
It is known that one of the first applications of the maxflow
problem is the restoration of binary images.
We take the binary image</p>
<img alt="_images/a.png" src="_images/a.png" />
<p>and add strong gaussian noise to it:</p>
<img alt="_images/a2.png" src="_images/a2.png" />
<p>You can download this image from this page using the right-click menu
of your browser. You can load it into Python with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">from</span> <span class="nn">scipy.misc</span> <span class="kn">import</span> <span class="n">imread</span>
<span class="kn">import</span> <span class="nn">maxflow</span>

<span class="n">img</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s">&quot;a2.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>We will restore the image minimizing the energy</p>
<div class="math">
<p><img src="_images/math/def4c219d2d0c2e4e2064b60f53791da187614f2.png" alt="E(\mathbf{x}) = \sum_i D_i(x_i) + \sum_{(i,j)\in\mathcal{C}} K|x_i - x_j|." /></p>
</div><p><img class="math" src="_images/math/2e099c2bbb0f22a490996e0e7efbb31c5da5ed9c.png" alt="\mathbf{x} \in \{0,1\}^N"/> are the labels of the restored image, <img class="math" src="_images/math/fc97ef67268cd4e91bacdf12b8901d7036c9a056.png" alt="N"/>
is the number of pixels. The unary term <img class="math" src="_images/math/c1ca728dc29b6f961b44600a9e531f22ea551b9d.png" alt="D_i(0)"/> (resp <img class="math" src="_images/math/e1cdb9af85722e4f253827a938645801c9e50413.png" alt="D_i(1)"/>)
is the penalty for assigning the value 0 (resp 1) to the i-th pixel. Each
<img class="math" src="_images/math/8dfcbccbc64a91b700ee90d800d2d0a0c2cda992.png" alt="D_i"/> depends on the values of the noisy image, which are denoted as
<img class="math" src="_images/math/245a5501248a6ea24f520f76d4140cedf08e1674.png" alt="p_i"/>:</p>
<div class="math">
<p><img src="_images/math/a46a5933ba980b82d62b2b12792b6717af67bc3e.png" alt="D_i(x_i) = \begin{cases} p_i &amp; \textrm{if } x_i=0\\ 255-p_i &amp; \textrm{if } x_i=1 \end{cases}." /></p>
</div><p>Thus, <img class="math" src="_images/math/8dfcbccbc64a91b700ee90d800d2d0a0c2cda992.png" alt="D_i"/> is low when assigning the label 0 to dark pixels or the
label 1 to bright pixels, and high otherwise.
The value <img class="math" src="_images/math/dfb064112b6c94470339f6571f69d07afc1c024c.png" alt="K"/> is the regularization strength. The larger <img class="math" src="_images/math/dfb064112b6c94470339f6571f69d07afc1c024c.png" alt="K"/>
the smoother the restoration. We fix it to 50.</p>
<p>The maximum flow algorithm is widely used to minimize energy functions of this
type. We build a graph which represents the above energy. This graph has as many
non-terminal nodes as pixels in the image. The nodes are connected in a grid
arrangement, so that the nodes corresponding to neighbor pixels are connected
by a forward and a backward edge. The capacities of all non-terminal edges
is <img class="math" src="_images/math/dfb064112b6c94470339f6571f69d07afc1c024c.png" alt="K"/>. The capacities of the edges from the source node are set
to <img class="math" src="_images/math/c1ca728dc29b6f961b44600a9e531f22ea551b9d.png" alt="D_i(0)"/>, and the capacities of the edges to the sink node are <img class="math" src="_images/math/e1cdb9af85722e4f253827a938645801c9e50413.png" alt="D_i(1)"/>.</p>
<p>We could build this graph as in the first example. First, we would add all the nodes.
Then, we would iterate over the nodes adding the edges properly. However, this is extremely
slow in Python, especially when dealing with large images or stacks of images.
<em>PyMaxflow</em> provides methods for building some complex graphs with a few calls.
In this example we review <tt class="docutils literal"><span class="pre">add_grid_nodes</span></tt>, <tt class="docutils literal"><span class="pre">add_grid_edges</span></tt>,
which add edges with a fixed capacity to the grid,
and <tt class="docutils literal"><span class="pre">add_grid_tedges</span></tt>, which sets
the capacities of the terminal edges for multiple nodes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Create the graph.</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">maxflow</span><span class="o">.</span><span class="n">Graph</span><span class="p">[</span><span class="nb">int</span><span class="p">]()</span>
<span class="c"># Add the nodes. nodeids has the identifiers of the nodes in the grid.</span>
<span class="n">nodeids</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">add_grid_nodes</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="c"># Add non-terminal edges with the same capacity.</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_grid_edges</span><span class="p">(</span><span class="n">nodeids</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="c"># Add the terminal edges. The image pixels are the capacities</span>
<span class="c"># of the edges from the source node. The inverted image pixels</span>
<span class="c"># are the capacities of the edges to the sink node.</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_grid_tedges</span><span class="p">(</span><span class="n">nodeids</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="mi">255</span><span class="o">-</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we perform the maxflow computation and get the results:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Find the maximum flow.</span>
<span class="n">g</span><span class="o">.</span><span class="n">maxflow</span><span class="p">()</span>
<span class="c"># Get the segments of the nodes in the grid.</span>
<span class="n">sgm</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_grid_segments</span><span class="p">(</span><span class="n">nodeids</span><span class="p">)</span>
</pre></div>
</div>
<p>The method <tt class="docutils literal"><span class="pre">get_grid_segments</span></tt> returns an array with
the same shape than <tt class="docutils literal"><span class="pre">nodeids</span></tt>. It is almost equivalent to calling
<tt class="docutils literal"><span class="pre">get_segment</span></tt> once for each node in <tt class="docutils literal"><span class="pre">nodeids</span></tt>, but much faster.
For the i-th cell, the array stores <tt class="xref docutils literal"><span class="pre">False</span></tt>
if the i-th node belongs to the <tt class="docutils literal"><span class="pre">maxflow.SOURCE</span></tt> segment (i.e., the
corresponding pixel has the label 1) and <tt class="xref docutils literal"><span class="pre">True</span></tt> if the
node belongs to the <tt class="docutils literal"><span class="pre">maxflow.SINK</span></tt> segment (i.e., the corresponding
pixel has the label 0). We now get the labels for each pixel
and reshape the result using the shape of the original image:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># The labels should be 1 where sgm is False and 0 otherwise.</span>
<span class="n">img2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">sgm</span><span class="p">))</span>
<span class="c"># Show the result.</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">ppl</span>
<span class="n">ppl</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img2</span><span class="p">)</span>
<span class="n">ppl</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The result is:</p>
<a class="reference internal image-reference" href="_images/binary.png"><img alt="_images/binary.png" src="_images/binary.png" style="width: 540.0px; height: 473.25px;" /></a>
<p>This is a comparison between the original image (left), the noisy one (center)
and the restoration of this example (right):</p>
<a class="reference internal image-reference" href="_images/comparison.png"><img alt="_images/comparison.png" src="_images/comparison.png" style="width: 625.5px; height: 300.0px;" /></a>
</div>
<div class="section" id="fast-approximate-energy-minimization">
<h2>Fast approximate energy minimization<a class="headerlink" href="#fast-approximate-energy-minimization" title="Permalink to this headline">¶</a></h2>
<p>TO DO.</p>
<table class="docutils citation" frame="void" id="boykov06" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[BOYKOV06]</a></td><td><em>Graph Cuts in Vision and Graphics: Theories and Applications</em>.
Yuri Boykov, Olga Veksler.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Tutorial</a><ul>
<li><a class="reference internal" href="#getting-started">Getting started</a></li>
<li><a class="reference internal" href="#a-first-example">A first example</a></li>
<li><a class="reference internal" href="#binary-image-restoration">Binary image restoration</a></li>
<li><a class="reference internal" href="#fast-approximate-energy-minimization">Fast approximate energy minimization</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Welcome to PyMaxflow&#8217;s documentation!</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="maxflow.html"
                        title="next chapter">Maxflow package</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/tutorial.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="maxflow.html" title="Maxflow package"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Welcome to PyMaxflow’s documentation!"
             >previous</a> |</li>
        <li><a href="index.html">PyMaxflow v0.0.3beta documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Pablo Márquez Neila.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>